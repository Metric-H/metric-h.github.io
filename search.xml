<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Blog 写作环境</title>
      <link href="2021/05/09/hexoenv/"/>
      <url>2021/05/09/hexoenv/</url>
      
        <content type="html"><![CDATA[<p>博客写了一段时间了，稍微记录一下常用的一些配置，也防止之后遗忘。</p><h2 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown 写作"></a>Markdown 写作</h2><p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>支持 Markdown 语法的编辑器很多，目前我选择的是 <a href="https://www.typora.io/">Typora</a> 。它是一款免费的 Markdown 编辑器，界面非常简洁优雅，功能也很强大（下文会介绍到），目前来说使用体验很棒~</p><h2 id="图床与图片上传管理"><a href="#图床与图片上传管理" class="headerlink" title="图床与图片上传管理"></a>图床与图片上传管理</h2><p>写博客肯定离不开图，不管是笔记还是游记，多元化的信息可以使阅读变得更轻松。</p><p>如果使用本地图片，等待编译完再上传，一旦图片总大小比较大时，限制可能会比较多，而且也不太适于多人编辑。图床，顾名思义就是进行图片存储的服务器，同时允许对外连接网络，所有人可以访问。使用图床的好处并不止于博客，于各大论坛回帖时，使用图床能够很方便地上传高清图片，而不会受到论坛的限制。</p><p>有了图床，我们可以将图片（或 GIF 等）返回一个 URL 链接，而不需要专门编辑、存放、管理众多杂乱无章的图片，直接复制、粘到 Markdown 编辑器里就能显示出来。但是一旦图片数量多起来，反复切换应用与浏览器、复制粘贴链接都是比较麻烦的。这个时候我建议使用图片上传软件 <a href="https://github.com/PicGo/">PicGo</a> 。PicGo 不仅是图片上传工具，同时也提供简易的图床相册管理功能。PicGo 开源且免费，跨平台支持 Windows、macOS、Linux 系统，使用极为简单。</p><p>初始配置存储方案，我目前使用的是 SMMS 。首先进入 <a href="https://sm.ms/">SMMS图床</a>，注册登录之后，点击右上角「User - Dashboard」，在「APItoken」中可以查看个人专属 Secret Token 。PicGo 中，打开「插件设置」，搜索「SMMS」，即可安装，然后将 token 复制到「图床设置 - SM.MS 图床」，完成配置。</p><p>使用时，拖放图片到主窗口或 mini 窗口（macOS 为顶部状态栏），PicGo 会自动上传至云服务器并返回链接到剪贴板，直接粘贴即可使用。而且 PicGo 还支持直接将剪贴板图片或 URL 一键上传。</p><p>PicGo 同时也提供简易的图床相册管理功能，打开「相册区」，可以看到当前图床中所有的图片集合，支持复制、修改 URL 和删除的操作。</p><h2 id="软件联动"><a href="#软件联动" class="headerlink" title="软件联动"></a>软件联动</h2><p>之所以推荐 PicGo ，很大一部分原因是它带有大量强大的插件。2.0 版本之后，你可以简单通过「插件设置」页面，搜索安装插件。安装完成后，可以点击插件右下方齿轮图标，进行更新、禁用、卸载、配置及使用等功能。（注意：由于 PicGo 要使用 npm 来安装插件，所以用户必须先安装 <a href="https://nodejs.org/en/">Node.js</a> ，使用 Hexo 的话应该已经装过了吧^_^）</p><ul><li>vs-picgo ：VScode 中使用（VScode 有 PicGo 插件，需要在扩展市场先安装再配置）。</li><li>picgo-plugin-super-prefix ：自定义图像文件名和前缀。</li><li>picgo-plugin-quick-capture ：<strong>仅支持 2.2.0+ 版本的 PicGo</strong>，提供一键截图 + 上传的功能。</li><li>picgo-plugin-pic-migrater ：Markdown 文件中图片的<strong>图床迁移</strong>。大致分三步：<ul><li>进入 PicGo 插件设置，文件名后缀设置为生成转换后的文件名后缀。比如，要转换 <code>first.md</code>，则当前目录下转换后的文件名为 <code>first_nex.md</code>。</li><li>只包含（不包含）：仅（不）转换包含自定义设置的图床链接。</li><li>上传文件（文件夹），等待转换完成，片刻即可在当前目录生成自定义文件名后缀的转换完成的文件了。</li></ul></li></ul><p>PicGo 跟 Typora 的联动是我选择它们的一大原因。直接拖拽或直接将剪贴板图片粘贴进 Typora，便可实现自动上传到 PicGo 图床。如下所示：</p><p><img src="https://i.loli.net/2021/05/09/dzwympqSIjE1HDv.gif" alt="示例"></p><p>打开 Typora，使用快捷键 <code>Ctrl + ,</code> 进入偏好设置，找到「图像」修改相应设置选项。</p><ul><li>插入图片时选择「上传图片」，然后勾选「对本地图片应用规则」「对网络图片应用规则」「插入图片自动转义」。</li><li>上传服务设定：PicGo (app)，PicGo 路径：自己主机中安装的 <code>PicGo.exe</code> 的存放路径。</li><li>点击「验证图片上传选项」，如果 PicGo 里多出两张图片，就说明连接成功了。</li></ul><p><img src="https://i.loli.net/2021/05/09/LXUPIiNqDk3sTx8.png" alt="设置"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Extrasolar Planets</title>
      <link href="2021/04/29/planets/"/>
      <url>2021/04/29/planets/</url>
      
        <content type="html"><![CDATA[<p>最近看到了系外行星的探测方法——视向速度法（radial velocity measurements），还挺有意思的，顺手记录一下。</p><h2 id="系外行星探测方法"><a href="#系外行星探测方法" class="headerlink" title="系外行星探测方法"></a>系外行星探测方法</h2><p>系外行星直接探测的难度很大，因为行星通常离主星很近，同时又很暗，而由于仪器及大气扰动造成的星光衍射会将行星掩盖。比如我们的太阳系，在可见光波段太阳亮度约为木星亮度的 $10^9$，当然，这种差距在红外波段会减小。正因如此绝大多数系外行星探测方法，都是间接探测法。主要原理是依靠行星对主星的作用，或者行星在主星到地球的光路上。在众多间接探测方法中，视向速度法与测光凌星法，是迄今为止最成功的系外行星探测方法。下面主要介绍视向速度法。</p><h2 id="视向速度法简介"><a href="#视向速度法简介" class="headerlink" title="视向速度法简介"></a>视向速度法简介</h2><p>虽然我们不能直接看见行星，但是可以探测到行星对恒星的引力影响。如下图所示：</p><p><img src="https://i.loli.net/2021/04/30/Xc6tSgNTmZ1lpFK.jpg" alt="Radial velocity"></p><p>行星与恒星由于引力作用，绕他们共同的质心做开普勒运动，恒星会周期性的靠近我们或者远离我们。由于多普勒效应，恒星靠近我们的时候，其光谱会蓝移，而当恒星远离我们的时候，其光谱会红移。由于行星对恒星的作用非常小，需要足够的信噪比才能确定其谱线移动。虽然测量单个谱线，就可以得到谱线平移量，但是其测量误差非常大，因此需要测量大量恒星谱线，来确定光谱平移量。因此视向速度法多观测晚型星，因其发射线众多。不仅如此，早期恒星自转速度快，会导致光谱自转致宽，不利于确定其谱线中心，而且早型星激烈的恒星活动会带来显著的噪声。</p><p>太阳系中，对太阳带来最大视向速度的是木星，可造成太阳 $12.5 m/s$ 的视向速度振幅以及 $11.86 yr$ 的视向速度周期。</p><h2 id="视向速度法模型"><a href="#视向速度法模型" class="headerlink" title="视向速度法模型"></a>视向速度法模型</h2><p>由于我们对行星级质量感兴趣，因此动力学主要由多个质量体的引力相互作用来描述。模型涉及的开普勒轨道参数主要有：行星轨道周期（$P$）、轨道偏心率（$e$）、轨道的倾斜度（$i$）、升交点经度（$\omega$）、平近点角（$M$）等。</p><p>对于多行星系统，使用多体模型正确模拟行星运动是非常重要的。由于在大多情况下，行星之间的摄动影响在与观测持续时间相当的时间尺度上可以忽略不计，此时，可以用多个无摄动的开普勒轨道的线性叠加来描述多行星系统引起的视向速度扰动。</p><p>对于无摄动的开普勒轨道上的行星，平近点角是开普勒轨道主要参数中唯一随时间变化的，此时径向速度曲线可由固定轨道参数的 $N$ 个开普勒轨道的叠加来描述：</p><p>$$ v_{r}(t)=\sum_{i=1}^{N} K_{i}\left[\cos\left(T_{i}+\omega_{i}\right)+e_{i} \cos \omega_{i}\right] $$</p><p>其中 $i$ 是行星序号，$K$ 是视向速度的半振幅 。$T$ 是真近点角，与偏近点角 $E$ 有关：</p><p>$$ \tan \left(\frac{T}{2}\right)=\sqrt{\frac{1+e}{1-e}} \tan \left(\frac{E}{2}\right) $$</p><p>而偏近点角 $E$ 与平近点角 $M$ 有如下关系：</p><p>$$ E(t)-e \sin [E(t)]=M(t)-M_{0}=\frac{2 \pi}{P}(t-\tau) $$</p><p>其中 $M_{0}$ 是常数，代表 $t = \tau$ 时的轨道位相。视向速度半振幅 $K$ 与行星质量 $m$ 有关：</p><p>$$ K=\frac{m \sin i}{M_{*}}\left(\frac{2 \pi G M_{*}}{P}\right)^{1 / 3}\left(1-e^{2}\right)^{-1 / 2}\left(1+\frac{m}{M_{*}}\right)^{-2 / 3} $$</p><p>其中 $M_{*}$ 是指恒星的质量。</p><p>实际模拟时，可以先假设行星轨道是圆轨道，此时偏心率 $e$ 为零，可以很大程度上简化计算过程。</p><p>详细的介绍可以参看<a href="https://iopscience.iop.org/article/10.1086/500802">Eric B. Ford 2006 <em>ApJ</em> <strong>642</strong> 505</a></p>]]></content>
      
      
      <categories>
          
          <category> Astronomy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 花括号问题</title>
      <link href="2021/04/18/hexo-gua-hao-wen-ti/"/>
      <url>2021/04/18/hexo-gua-hao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>部署最新文章之后，发现代码区块中的花括号‘{‘，’}’均不能正常显示，变成了”&amp;#123“以及”&amp;#125”。</p><p>网上查找之后基本确定是代码高亮插件 <strong>hexo-prism-plugin</strong> 的问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>删除插件。大家可以直接升级 <strong>Hexo</strong> 到 5.x 最新版本，去掉 <strong>hexo-prism-plugin</strong> 插件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> uninstall hexo-prism-plugin</code></pre><p>然后将内置的 <code>prismjs.enable</code> 设置为 <code>true</code> 。</p><p>重新生成并部署博客，显示恢复正常。</p></li><li><p>继续使用插件，但是插件模块源码中，花括号没有被写入，需要自行修正。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> myBlog/node_modules/hexo-prism-plugin/src</code></pre><p>修改 <em>index.js</em> 文件即可：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">const</span> map <span class="token operator">=</span><span class="token punctuation">{</span>  <span class="token string">'&amp;#39;'</span><span class="token operator">:</span> <span class="token string">'\''</span><span class="token punctuation">,</span>  <span class="token string">'&amp;amp;'</span><span class="token operator">:</span> <span class="token string">'&amp;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;gt;'</span><span class="token operator">:</span> <span class="token string">'>'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;lt;'</span><span class="token operator">:</span> <span class="token string">'&lt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;quot;'</span><span class="token operator">:</span> <span class="token string">'"'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#123;'</span><span class="token operator">:</span> <span class="token string">'{'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#125;'</span><span class="token operator">:</span> <span class="token string">'}'</span><span class="token punctuation">}</span><span class="token punctuation">;</span># 重点是添加最后两行</code></pre><p>重新生成博客并部署，显示恢复正常。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P&amp;S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BASH 学习小记</title>
      <link href="2021/04/16/bash-bi-ji/"/>
      <url>2021/04/16/bash-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-shell-？"><a href="#什么是-shell-？" class="headerlink" title="什么是 shell ？"></a>什么是 shell ？</h2><p>其实 shell 只是提供用户操作系统的一个接口，因此这个 shell 需要可以调用其他软件。 很多指令，包括 man、chmod、chown、vi 等等，都是独立的应用程序，但是我们可以通过 shell（就是命令行模式）操作这些应用程序，让这些应用程序调用核心运行。shell 极其重要的特性就是效率很高。</p><h3 id="Bash-shell-的功能"><a href="#Bash-shell-的功能" class="headerlink" title="Bash shell 的功能"></a>Bash shell 的功能</h3><p>可直接通过以下命令学习，但是^_^</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">man</span> <span class="token function">bash</span></code></pre><p>bash 的优点有很多：</p><ul><li><p>命令编修能力(history)：记忆使用过的指令</p></li><li><p>命令与档案补全功能：[tab] 按键的好处</p></li><li><p>命令别名设定功能：alias。如：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">alias</span> lm<span class="token operator">=</span><span class="token string">'ls -al'</span></code></pre></li><li><p>工作控制、前景背景控制：(job control, foreground, background)</p></li><li><p>程序化脚本：(shell scripts)</p></li><li><p>通配符： (Wildcard)</p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如 PATH、 HOME、MAIL、SHELL 等，都是很重要的，为了区别于自定义变量，环境变量通常以大写字符表示。</p><p>环境变量可以帮我们达到很多功能～包括家目录的变换、提示字符的显示、执行文件搜寻的路径等。我们可以利用两个指令查阅目前的 shell 环境中有多少默认环境变量，分别是 env 与 export。</p><p>set 除了环境变量外， 还会将其他在 bash 内的变量通通显示出来。</p><ul><li><p>PS1：（提示字符的设定）</p><p>这个东西就是我们的『命令提示字符』，当我们每次按下 [Enter] 按键执行某个指令后，最后要再次出现提示字符时，就会主动去读取这个变量值。可以通过如下方法修改：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> /home$ PS1<span class="token operator">=</span><span class="token string">'[\u@\h \w \a #\#]\$'</span><span class="token punctuation">[</span>root@www /home 17:02 <span class="token comment" spellcheck="true">#85]$</span></code></pre></li><li><p>$：（关于本 shell 的 PID）</p></li><li><p>?：（关于上个执行指令的回传值）</p></li></ul><p>当你登入 Linux 并取得一个 bash 后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序。</p><p>我们在原本的 bash 底下执行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)， 那原本的 bash 就会处于暂停的情况 (睡着了，就是 sleep)。若要回到原本的 bash ， 就必须将第二个 bash 结束掉 (下达 exit 或 logout) 。</p><p>子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自定义变量。</p><h3 id="变量的取用：echo"><a href="#变量的取用：echo" class="headerlink" title="变量的取用：echo"></a>变量的取用：echo</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$variable</span><span class="token keyword">echo</span> <span class="token variable">$PATH</span><span class="token keyword">echo</span> <span class="token variable">${PATH}</span></code></pre><p>注意变量名称前加上 $ ，echo 功能不止于此，可以 man echo 查看。</p><h3 id="变量的设定规则"><a href="#变量的设定规则" class="headerlink" title="变量的设定规则"></a>变量的设定规则</h3><ol><li><p>变量与变量内容以一个等号『=』相连结</p></li><li><p>等号两边不能直接接空格符</p></li><li><p>变量名称只能是英文字母与数字，但是开头字符不能是数字</p></li><li><p>变量内容若有空格符可使用双引号『”』或单引号『’』将变量内容结合起来，但：</p><ul><li><p>双引号内的特殊字符如 $ 等，可以保有原本的特性，如：</p><pre class=" language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"lang is <span class="token variable">$LANG</span>"</span>$ <span class="token keyword">echo</span> <span class="token variable">$var</span>lang is en_US</code></pre></li><li><p>单引号内的特殊字符则仅为一般字符 (纯文本)，如：</p><pre class=" language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">'lang is <span class="token variable">$LANG</span>'</span>$ <span class="token keyword">echo</span> <span class="token variable">$var</span>lang is <span class="token variable">$LANG</span></code></pre></li></ul></li><li><p>可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, , 空格符等)变成一般字符</p></li><li><p>在一串指令中，还需要藉由其他指令提供的信息，可以使用反单引号<code>『`指令`』</code>或 『$(指令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 例如想要获得核心版本的设定：</p><pre class=" language-bash"><code class="language-bash">$ version<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span>$ <span class="token keyword">echo</span> <span class="token variable">$version</span>4.15.0-140-generic</code></pre></li><li><p>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如：</p><pre class=" language-bash"><code class="language-bash">$ PATH<span class="token operator">=</span><span class="token string">"<span class="token variable">$PATH</span>"</span>:/home/bin</code></pre></li><li><p>若该变量需要在其他子程序执行，则需要以 export 使变量变成环境变量：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">export</span> PATH</code></pre></li><li><p>通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) </p></li><li><p>取消变量的方法为使用 unset ：『unset 变量名称』</p></li></ol><h3 id="变量键盘读取、数组与宣告：read-array-declare"><a href="#变量键盘读取、数组与宣告：read-array-declare" class="headerlink" title="变量键盘读取、数组与宣告：read, array, declare"></a>变量键盘读取、数组与宣告：read, array, declare</h3><ul><li><p>read ：读取需要键盘输入的变量</p><p>选项与参数：</p><p>-p ：后面可以接提示字符 </p><p>-t ：后面可以接等待的『秒数』</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">read</span> -p <span class="token string">"Please keyin your name: "</span> -t 30 namedPlease keyin your name: Metric$ <span class="token keyword">echo</span> <span class="token variable">$named</span>Metric<span class="token punctuation">(</span>提示使用者 30 秒内输入自己的名字，将该输入字符串作为 named 的变量内容<span class="token punctuation">)</span></code></pre></li><li><p>declare / typeset ：宣告变量的类型。</p><p>如果使用 declare 后面没有接任何参数，那么 bash 就会主动将所有变量名称与内容显示出来，类似使用 set 。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">declare</span> <span class="token punctuation">[</span>-aixr<span class="token punctuation">]</span> variable</code></pre><p>选项与参数：</p><p>-a ：将后面名为 variable 的变量定义成为数组 (array) 类型</p><p>-i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型</p><p>-x ：用法与 export 一样，就是将后面的 variable 变成环境变量</p><p>-r ：将变量定义成为 readonly 类型，该变量不可被更改内容，也不能 unset</p><p>tip：将 - 变成 + 可以进行『取消』动作。但如果你不小心将变量定义为『只读』，通常得要注销再登入才能复原该变量的类型。</p><p>在默认情况下，bash 对于变量有基本定义：</p><ul><li>变量类型默认为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。</li><li>bash 环境中的数值运算，预设最多仅能到达整数形态，所以 1/3 结果是 0 。</li></ul></li><li><p>数组（array）</p><pre class=" language-bash"><code class="language-bash">$ var<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"small"</span>$ var<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"normal"</span>$ var<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"large"</span>$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${var[1]}</span>, <span class="token variable">${var[2]}</span>, <span class="token variable">${var[3]}</span>"</span>small, normal, large</code></pre></li></ul><h3 id="变量内容的删除、取代与替换"><a href="#变量内容的删除、取代与替换" class="headerlink" title="变量内容的删除、取代与替换"></a>变量内容的删除、取代与替换</h3><ul><li><p># ：从变量内容的最前面开始向右，删除符合取代文字的『最短的』那一个；</p></li><li><p>## ：从变量内容的最前面开始向右，删除符合取代文字的『最长的』那一个。</p><pre class=" language-bash"><code class="language-bash">$ path<span class="token operator">=</span><span class="token variable">${PATH}</span>$ <span class="token keyword">echo</span> <span class="token variable">$path</span>/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<span class="token comment" spellcheck="true"># 删去前两个含 kerberos 的目录（通过通配符 * 来取代 0 到无穷多个任意字符）（在 PATH 这个变量的内容中，每个目录都是以冒号『:』隔开）</span>$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>path<span class="token comment" spellcheck="true">#/*kerberos/bin:}</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</code></pre></li><li><p>如果想要『从后面向前删除变量内容』呢？ 这个时候就得使用百分比 (%) 符号了。% 与 %%  的意义其实与 # 及 ## 类似。</p></li></ul><hr><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将 path 的变量内容中的 sbin 替换成大写 SBIN ：</span>$ <span class="token keyword">echo</span> <span class="token variable">${path/sbin/SBIN}</span>/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin$ <span class="token keyword">echo</span> <span class="token variable">${path//sbin/SBIN}</span>/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/SBIN:/usr/local/bin:/SBIN:/bin:/usr/SBIN:/usr/bin:/root/bin<span class="token comment" spellcheck="true"># 如果是两条斜线，那么就变成所有符合的内容都会被替换。</span></code></pre><hr><ul><li><p>变量的测试与内容替换</p><p>底下的例子当中，那个 var 与 str 为变量，我们想要针对 str 是否有设定来决定 var 的值！一般来说，str: 代表『str 没设定或为空的字符串时』；至于 str 则仅为 『没有该变数』。</p><table><thead><tr><th align="center">变量设定方式</th><th align="center">str 没有设定</th><th align="center">str 为空字符串</th><th align="center">str 已设定为非空字符串</th></tr></thead><tbody><tr><td align="center">var=${str-expr}</td><td align="center">var=expr</td><td align="center">var=</td><td align="center">var=$str</td></tr><tr><td align="center">var=${str:-expr}</td><td align="center">var=expr</td><td align="center">var=expr</td><td align="center">var=$str</td></tr><tr><td align="center">var=${str+expr}</td><td align="center">var=</td><td align="center">var=expr</td><td align="center">var=expr</td></tr><tr><td align="center">var=${str:+expr}</td><td align="center">var=</td><td align="center">var=</td><td align="center">var=expr</td></tr><tr><td align="center">var=${str=expr}</td><td align="center">str=expr<br />var=expr</td><td align="center">str 不变<br />var=</td><td align="center">str 不变<br />var=$str</td></tr><tr><td align="center">var=${str:=expr}</td><td align="center">str=expr<br />var=expr</td><td align="center">str=expr<br />var=expr</td><td align="center">str=不变<br />var=$str</td></tr><tr><td align="center">var=${str?expr}</td><td align="center">expr 输出至 stderr</td><td align="center">var=</td><td align="center">var=$str</td></tr><tr><td align="center">var=${str:?expr}</td><td align="center">expr 输出至 stderr</td><td align="center">expr 输出至 stderr</td><td align="center">var=$str</td></tr></tbody></table><p>基本上这种变量的测试也能够通过 shell script 内的 if…then… 来处理， 不过既然 bash 提供了这么简单的方法来测试变量，那我们也可以多尝试一下！</p></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="命令别名设定：alias-unalias"><a href="#命令别名设定：alias-unalias" class="headerlink" title="命令别名设定：alias, unalias"></a>命令别名设定：alias, unalias</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">alias</span> lm<span class="token operator">=</span><span class="token string">'ls -al | more'</span></code></pre><p>此时多出了一个可以执行的指令，这个指令名称为 lm ，其实他是执行 ls -al | more 。</p><p>要注意的是：『alias 的定义规则于变量定义的规则几乎相同』。</p><p>只使用 alias 可以知道目前有哪些命令别名。另外：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">unalias</span> lm</code></pre><p>这样就取消了别名。</p><p>注意，命令别名是『新创一个指令， 你可以直接下达该指令』，变量则需要使用类似『 echo 』指令才能够调出变量的内容。</p><h3 id="历史命令：history"><a href="#历史命令：history" class="headerlink" title="历史命令：history"></a>历史命令：history</h3><p>选项与参数： </p><p>n ：数字，意思是『列出最近的 n 个命令行表』</p><p>-c ：将目前的 shell 中的所有 history 内容全部消除</p><p>-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则预设写入 ~/.bash_history</p><p>-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中</p><p>-w ：将目前的 history 记忆内容写入 histfiles 中</p><h2 id="Bash-shell-的操作环境"><a href="#Bash-shell-的操作环境" class="headerlink" title="Bash shell 的操作环境"></a>Bash shell 的操作环境</h2><p>系统有一些环境配置文件的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境。而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。要注意的是， 我们前几个小节谈到的命令别名、自定义的变量等，在你注销 bash 后就会失效，所以你想要保留你的设定，就得将这些设定写入配置文件才行。</p><p>在开始介绍 bash 的配置文件前，我们一定要先知道的就是 login shell 与 non-login shell！ 重点在于有没有登入 (login)。</p><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>一般来说，login  shell 其实只会读取这两个配置文件：</p><ol><li>/etc/profile：这是系统整体的设定，你最好不要修改这个档案；</li><li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里！</li></ol><p>bash 的 login shell 所读取的整体环境配置文件其实只有 /etc/profile，但是 /etc/profile 还会呼唤出其他的配置文件，所以让我们的 bash 操作接口变得非常友善。</p><hr><p>bash 在读完了整体环境设定 /etc/profile 并藉此呼唤其他配置文件后，接下来则是会读取使用者的个 人配置文件。在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别 是：</p><ol><li>~/.bash_profile</li><li> ~/.bash_login</li><li>~/.profile</li></ol><p>其实 bash 的 login shell 设定只会读取上面三个档案其中的一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个档案不论是否存在，都不会被读取。</p><p>bash 配置文件的读入方式比较有趣，主要是透过一个指令『 source 』 来进行的！ 也就是说~/.bash_profile 其实会再呼叫 ~/.bashrc 的设定内容，所以最终被读取的配置文件是『 ~/.bashrc 』这个档案，你将自己的偏好设定写入该档案即可。</p><hr><p>由于 /etc/profile 与 ~/.bash_profile 都是在打开 login shell 的时候才会读取的配置文件，如果你将自己的偏好设定写入上述的档案后，通常都是得注销再登入后，该设定才会生效。那么，能不能直接读取配置文件而不注销登入呢？那就得用 source 这个指令。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">source</span> 配置文件名</code></pre><p>利用 source 或小数点 (.) 都可以将配置文件的内容读到目前的 shell 环境中。</p><p>若是需要使用不同环境配置文件，可以针对不同的环境分别编写属于该环境的配置文件，当需要该环境时，就直接『 source 变量配置文件 』。</p><h3 id="non-login-shell"><a href="#non-login-shell" class="headerlink" title="non-login shell"></a>non-login shell</h3><p>当你打开 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已。</p><h3 id="bash-默认的组合键"><a href="#bash-默认的组合键" class="headerlink" title="bash 默认的组合键"></a>bash 默认的组合键</h3><table><thead><tr><th align="center">组合按键</th><th align="center">执行结果</th></tr></thead><tbody><tr><td align="center">Ctrl + C</td><td align="center">终止目前的命令</td></tr><tr><td align="center">Ctrl + D</td><td align="center">输入结束 (EOF)，例如邮件结束的时候</td></tr><tr><td align="center">Ctrl + M</td><td align="center">就是 Enter</td></tr><tr><td align="center">Ctrl + S</td><td align="center">暂停屏幕的输出</td></tr><tr><td align="center">Ctrl + Q</td><td align="center">恢复屏幕的输出</td></tr><tr><td align="center">Ctrl + U</td><td align="center">在提示字符下，将整列命令删除</td></tr><tr><td align="center">Ctrl + Z</td><td align="center">『暂停』目前的命令</td></tr></tbody></table><h3 id="通配符（wildcard）与特殊符号"><a href="#通配符（wildcard）与特殊符号" class="headerlink" title="通配符（wildcard）与特殊符号"></a>通配符（wildcard）与特殊符号</h3><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">代表『 0 个到无穷多个』任意字符</td></tr><tr><td align="center">?</td><td align="center">代表『一定有一个』任意字符</td></tr><tr><td align="center">[ ]</td><td align="center">同样代表『一定有一个在括号内』的字符(非任意字符)。<br />例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』</td></tr><tr><td align="center">[ - ]</td><td align="center">若有减号在中括号内时，代表『在编码顺序内的所有字符』。<br />例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td></tr><tr><td align="center">[^ ]</td><td align="center">若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』。<br />例如 [^ abc] 代表一定有一个字符，只要是非 a, b, c 的其他字符就接受。</td></tr></tbody></table><pre class=" language-bash"><code class="language-bash">$ LANG<span class="token operator">=</span>C                <span class="token operator">&lt;=</span><span class="token operator">=</span>由于与编码有关，先设定一下语系<span class="token comment" spellcheck="true"># 找出 /etc/ 底下以 cron 为开头的文档名</span>$ ll -d /etc/cron*        <span class="token operator">&lt;=</span><span class="token operator">=</span>加上 -d 是为了仅显示目录而已<span class="token comment" spellcheck="true"># 找出 /etc/ 底下文件名『刚好是五个字母』的文件名</span>$ ll -d /etc/?????        <span class="token operator">&lt;=</span><span class="token operator">=</span>由于 ? 表示一定有一个，所以五个 ? 就对了<span class="token comment" spellcheck="true"># 找出 /etc/ 底下文件名含有数字的文件名</span>$ ll -d /etc/*<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*    <span class="token operator">&lt;=</span><span class="token operator">=</span>记得中括号左右两边均需 *<span class="token comment" spellcheck="true"># 找出 /etc/ 底下，文档名开头不是小写字母的文件名</span>$ ll -d /etc/<span class="token punctuation">[</span>^a-z<span class="token punctuation">]</span>*    <span class="token operator">&lt;=</span><span class="token operator">=</span>注意中括号左边没有 *<span class="token comment" spellcheck="true"># 将上一个例子找到的档案复制到 /tmp 中</span>$ <span class="token function">cp</span> -a /etc/<span class="token punctuation">[</span>^a-z<span class="token punctuation">]</span>* /tmp</code></pre><hr><table><thead><tr><th align="center">符号</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">#</td><td align="center">批注符号：这个最常被使用在 script 当中，视为说明。此后的数据均不执行</td></tr><tr><td align="center">\</td><td align="center">跳脱符号：将『特殊字符或通配符』还原成一般字符</td></tr><tr><td align="center">|</td><td align="center">管线 (pipe)：分隔两个管线命令的界定</td></tr><tr><td align="center">;</td><td align="center">连续指令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同)</td></tr><tr><td align="center">~</td><td align="center">用户的家目录</td></tr><tr><td align="center">$</td><td align="center">取用变量前导符：亦即是变量前需要加的变量取代值</td></tr><tr><td align="center">&amp;</td><td align="center">工作控制 (job control)：将指令变成背景下工作</td></tr><tr><td align="center">!</td><td align="center">逻辑运算意义上的『非』， not 的意思</td></tr><tr><td align="center">/</td><td align="center">目录符号：路径分隔的符号</td></tr><tr><td align="center">&gt;, &gt;&gt;</td><td align="center">数据流重导向：输出导向，分删是『取代』与『累加』</td></tr><tr><td align="center">&lt;, &lt;&lt;</td><td align="center">数据流重导向：输入导向</td></tr><tr><td align="center">‘ ‘</td><td align="center">单引号，不具有变量置换的功能</td></tr><tr><td align="center">“ “</td><td align="center">具有变量置换的功能</td></tr><tr><td align="center">``</td><td align="center">两个『 ` 』中间为可以先执行的指令，亦可使用 $( )</td></tr><tr><td align="center">( )</td><td align="center">在中间为子 shell 的起始与结束</td></tr><tr><td align="center">{ }</td><td align="center">在中间为命令区块的组合</td></tr></tbody></table><h2 id="数据流重导向-Redirection"><a href="#数据流重导向-Redirection" class="headerlink" title="数据流重导向(Redirection)"></a>数据流重导向(Redirection)</h2><p>数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，传输到其他地方，如文档或是装置(例如打印机)。</p><h3 id="standard-output-与-standard-error-output"><a href="#standard-output-与-standard-error-output" class="headerlink" title="standard output 与 standard error output"></a>standard output 与 standard error output</h3><p>标准输出指的是『指令执行所回传的正确的讯息』，而标准错误输出可理解为『 指令执行失败后，所回传的错误信息』。</p><p>数据流重导向可以将 standard output  (简称 stdout) 与 standard error output (简称 stderr) 分别传送到其他的档案或装置去，而分别传送所用的特殊字符如下所示：</p><ol><li>标准输入(stdin)：代码为 0 ，使用 &lt; 或 &lt;&lt;</li><li>标准输出(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt;</li><li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</li></ol><p>若以 &gt; 输出到一个已存在的档案中，那个档案就会被覆盖。利用两个大于号 (&gt;&gt;) 时，若文档不存在，系统会主动建立这个文档；若该文档已存在， 则数据会在该文档的最下方累加进去。</p><p>如果是 standard error output 的错误数据呢？那就通过 2&gt; 及 2&gt;&gt; ，同样是覆盖 (2&gt;) 不累加 (2&gt;&gt;)的特性！我们在刚刚才谈到 stdout 代码是 1 而 stderr 代码是 2 ， 所以这个 2&gt; 是很容易理解的，而如果仅存在 &gt; 时，则代表预设的代码是 1 。也就是说：</p><ul><li>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的档案或装置上；</li><li>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的档案或装置上；</li><li>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的档案或装置上；</li><li>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的档案或装置上。</li></ul><h3 id="dev-null-垃圾桶黑洞装置与特殊写法"><a href="#dev-null-垃圾桶黑洞装置与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞装置与特殊写法"></a>/dev/null 垃圾桶黑洞装置与特殊写法</h3><p>如果我知道错误信息会产生，所以要将错误信息忽略掉而不显示或储存呢？ 这个时候黑洞装置 /dev/null 就很重要了， /dev/null 可以吃掉任何导向这个装置的信息。</p><p>如果我要将正确与错误数据通通写入同一个档案去呢？</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">></span> list 2<span class="token operator">></span> list    <span class="token operator">&lt;=</span><span class="token operator">=</span>错误$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">></span> list 2<span class="token operator">></span><span class="token operator">&amp;</span>1        <span class="token operator">&lt;=</span><span class="token operator">=</span>正确$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">&amp;</span><span class="token operator">></span> list            <span class="token operator">&lt;=</span><span class="token operator">=</span>正确</code></pre><p>第一行错误的原因是，由于两股数据同时写入一个档案，又没有使用特殊的语法， 此时两股数据可能会交叉写入该档案内，造成次序的错乱。所以虽然最终 list 档案还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。 至于写入同一个档案的特殊语法，如上所示，你可以使用 2&gt;&amp;1 也可以使用 &amp;&gt; 。 </p><h3 id="standard-input-：-lt-与-lt-lt"><a href="#standard-input-：-lt-与-lt-lt" class="headerlink" title="standard input ： &lt; 与 &lt;&lt;"></a>standard input ： &lt; 与 &lt;&lt;</h3><p>&lt; 就是『将原本需要由键盘输入的数据，改由档案内容来替代』的意思。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 利用 cat 指令建立一个档案的简单流程</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfiletesting<span class="token function">cat</span> <span class="token function">file</span> <span class="token function">test</span><span class="token operator">&lt;=</span><span class="token operator">=</span>这里按下 <span class="token punctuation">[</span>ctrl<span class="token punctuation">]</span>+d 离开$ <span class="token function">cat</span> catfiletesting<span class="token function">cat</span> <span class="token function">file</span> <span class="token function">test</span></code></pre><p>由于加入 &gt; 在 cat 后，所以那个 catfile 会被主动建立，而内容就是刚刚键盘上面输入的那两行数据。那我能不能用纯文本文件替代键盘输入呢？</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 用 stdin 替代键盘的输入以建立新档案的简单流程</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;</span> ~/.bashrc$ ll catfile ~/.bashrc-rw-r--r-- 1 root root 194 Sep 26 13:36 /root/.bashrc-rw-r--r-- 1 root root 194 Apr 16 18:29 catfile<span class="token comment" spellcheck="true"># 这两个档案的大小会一模一样！几乎像是使用 cp 复制一样！</span></code></pre><p>理解 &lt; 之后，再来看 &lt;&lt; 这连续两个小于号。它代表的是『结束的输入字符』。举个例子：『我要用 cat 直接将输入的信息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;&lt;</span> <span class="token string">"eof"</span><span class="token operator">></span> This is a test.<span class="token operator">></span> OK now stop<span class="token operator">></span> eof <span class="token operator">&lt;=</span><span class="token operator">=</span>输入这关键词，立刻就结束而不需要输入 <span class="token punctuation">[</span>ctrl<span class="token punctuation">]</span>+d$ <span class="token function">cat</span> catfileThis is a test.OK now stop. <span class="token operator">&lt;=</span><span class="token operator">=</span>只有这两行，不会存在关键词那一行</code></pre><hr><p>那么为何要使用命令输出重导向呢？</p><ul><li>屏幕输出的信息很重要，而且我们需要将它存下的时候</li><li>背景执行中的程序，不希望它干扰屏幕正常的输出结果时</li><li>一些系统的例行命令 (例如写在 /etc/crontab 中的档案) 的执行结果，希望可以存下时</li><li>一些执行命令的可能已知错诨信息，想以『 2&gt; /dev/null 』将它丢掉时</li><li>错诨信息与正确信息需要分别输出时</li></ul><h3 id="命令执行的判断依据：-amp-amp"><a href="#命令执行的判断依据：-amp-amp" class="headerlink" title="命令执行的判断依据：;, &amp;&amp;, ||"></a>命令执行的判断依据：;, &amp;&amp;, ||</h3><p>在某些情况下，很多指令需要一次输入去执行，而不要分次执行时，可以通过 shell script 去执行，或者是通过下面介绍的一次输入多重指令。</p><ul><li><p>cmd ; cmd (不考虑指令相关性的连续指令下达)</p><p>在指令与指令中间利用分号 (;) 隔开，这样一来，分号前的指令执行完后就会立刻接着执行后面的指令。</p></li><li><p>$? (指令回传值)与 &amp;&amp; 或 ||</p><p>两个指令之间有相依性，而这个相依性主要判断的地方就在于前一个指令执行的结果是否正确。如我想要在某个目录底下建立一个档案，也就是说，如果该目录存在的话， 那我才建立这个档案，如果不存在，那就算了。这样就要用到之前我们曾介绍过的指令回传值：『若前一个指令执行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值』。</p><table><thead><tr><th align="center">指令下达情况</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">cmd1 &amp;&amp; cmd2</td><td align="center">1. 若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。<br />2. 若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。</td></tr><tr><td align="center">cmd1 || cmd2</td><td align="center">1. 若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。<br />2. 若 cmd1 执行完毕且为错误 ($?≠0)，则开始执行 cmd2。</td></tr></tbody></table><p>上述的 cmd1 及 cmd2 都是指令。现在：(1)先判断一个目录是否存在； (2)若存在才在该目录底下建立一个档案。由于我们尚未介绍判断式 (test) 的使用，在这里我们使用 ls 以及回传值来判断目录是否存在：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 ls 查阅目录 /tmp/abc 是否存在，若存在则用 touch 建立 /tmp/abc/hehe</span>$ <span class="token function">ls</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> /tmp/abc/hehels: /tmp/abc: No such <span class="token function">file</span> or directory<span class="token comment" spellcheck="true"># ls 很干脆地说明找不到该目录，但并没有 touch 的错误，表示 touch 并没有执行</span>$ <span class="token function">mkdir</span> /tmp/abc$ <span class="token function">ls</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> /tmp/abc/hehe$ ll /tmp/abc-rw-r--r-- 1 root root 0 Apr 17 12:43 hehe</code></pre><p>能不能自动判断，如果没有该目录就建立呢？</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 测试 /tmp/abc 是否存在，若不存在则予以建立，若存在就不做任何事情</span>$ <span class="token function">rm</span> -r /tmp/abc    <span class="token operator">&lt;=</span><span class="token operator">=</span>先删除此目录以方便测试$ <span class="token function">ls</span> /tmp/abc <span class="token operator">||</span> <span class="token function">mkdir</span> /tmp/abcls: /tmp/abc: No such <span class="token function">file</span> or directory$ ll /tmp/abctotal 0             <span class="token operator">&lt;=</span><span class="token operator">=</span>结果出现了！有进行 <span class="token function">mkdir</span></code></pre><p>如果你再重复『 ls /tmp/abc || mkdir /tmp/abc 』，也不会出现重复 mkdir 的错误！这是因为 /tmp/abc 已经存在， 所以后续的 mkdir 就不会运行。</p><p>如果我想要建立 /tmp/abc/hehe 这个档案， 但我并不知道 /tmp/abc 是否存在：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 我不清楚 /tmp/abc 是否存在，但就是要建立 /tmp/abc/hehe 档案</span>$ <span class="token function">ls</span> /tmp/abc <span class="token operator">||</span> <span class="token function">mkdir</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> /tmp/abc/hehe</code></pre><p>由于 Linux 底下的指令都是由左往右执行的，若 /tmp/abc 存在故回传 $?=0，则因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 &amp;&amp; 遇到 $?=0 就开始建立 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被建立起来。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 "exist" ，若不存在，则显示 "not exist"！</span>$ <span class="token function">ls</span> /tmp/vbirding <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"exist"</span> <span class="token operator">||</span> <span class="token keyword">echo</span> <span class="token string">"not exist"</span><span class="token comment" spellcheck="true"># 注意，若写成如下形式会同时出现 not exist 与 exist </span>$ <span class="token function">ls</span> /tmp/vbirding <span class="token operator">||</span> <span class="token keyword">echo</span> <span class="token string">"not exist"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"exist"</span></code></pre><p>由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错。一般来说，假如判断式有三个，也就是：command1 &amp;&amp; command2 || command3，而且通常顺序不会变，因为一般来说， command2 与 command3 会放置肯定可以执行成功的指令。</p></li></ul><h2 id="管线命令-pipe"><a href="#管线命令-pipe" class="headerlink" title="管线命令(pipe)"></a>管线命令(pipe)</h2><p>如同前面所说， bash 命令执行的时候有输出的数据会出现，那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设定？ 这就牵涉到管线命令的问题了 (pipe) ，管线命令使用的是『 | 』这个界定符号。</p><p>假如我们想要知道 /etc/ 底下有多少档案，那么可以用 ls /etc 查阅，不过， 因为 /etc 底下档案太多，导致一口气就将屏幕塞满了～不知道前面输出的内容是啥？此时，我们可以通过 less 指令的协助，利用：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span> -al /etc <span class="token operator">|</span> <span class="token function">less</span></code></pre><p>如此一来，使用 ls 指令输出后的内容，就能够被 less 读取，并且利用 less 的功能，我们就能够前后翻动相关的信息了。其实这个管线命令 『 | 』仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard  error 并没有直接处理的能力。在每个管线后面接的第一个数据必定是『指令』，而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以作为『管线命令』，例如 less, more, head, tail 等都是可以接受 standard  input 的管线命令。而例如 ls, cp, mv 等就不是管线命令了，因为 ls, cp, mv 并不会接受来自 stdin 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p><ul><li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li><li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行</li></ul><h3 id="撷取命令：cut-grep"><a href="#撷取命令：cut-grep" class="headerlink" title="撷取命令：cut, grep"></a>撷取命令：cut, grep</h3><p>撷取命令就是将一段数据经过分析后，取出我们所想要的，或者是经由分析关键词，取得我们所想要的那一行。要注意的是，一般来说，撷取信息通常是针对『一行一行』分析的， 并不是整篇信息分析的。</p><ul><li><p>cut</p><p>选项与参数：</p><p>-d ：后面接分隔字符。与 -f 一起使用</p><p>-f ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思</p><p>-c ：以字符 (characters) 的单位取出固定字符区间</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将 PATH 变量取出，我要找出第五个路径。</span>$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span>/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:<span class="token comment" spellcheck="true"># 1 |    2   |  3  |    4    |       5      |       6      | 7</span>$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f 5<span class="token comment" spellcheck="true"># 如同上面的数字显示，我们是以『 : 』作为分隔，因此会出现 /usr/local/bin</span><span class="token comment" spellcheck="true"># 那么如果想要列出第 3 与第 5 呢？，就是这样：</span>$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f 3,5<span class="token comment" spellcheck="true"># 将 export 输出的信息，取第 12 字符以后的所有字符串</span>$ <span class="token function">export</span><span class="token keyword">declare</span> -x HISTSIZE<span class="token operator">=</span><span class="token string">"1000"</span><span class="token keyword">declare</span> -x INPUTRC<span class="token operator">=</span><span class="token string">"/etc/inputrc"</span><span class="token keyword">declare</span> -x KDEDIR<span class="token operator">=</span><span class="token string">"/usr"</span><span class="token keyword">declare</span> -x LANG<span class="token operator">=</span><span class="token string">"zh_TW.big5"</span>···（其它省略）···<span class="token comment" spellcheck="true"># 如果我们不想要『 declare -x 』时：</span>$ <span class="token function">export</span> <span class="token operator">|</span> <span class="token function">cut</span> -c 12-HISTSIZE<span class="token operator">=</span><span class="token string">"1000"</span>INPUTRC<span class="token operator">=</span><span class="token string">"/etc/inputrc"</span>KDEDIR<span class="token operator">=</span><span class="token string">"/usr"</span>LANG<span class="token operator">=</span><span class="token string">"zh_TW.big5"</span>···<span class="token punctuation">(</span>其他省略<span class="token punctuation">)</span>···<span class="token comment" spellcheck="true"># 用 -c 可以处理具有一定格式的输出数据</span><span class="token comment" spellcheck="true"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等</span><span class="token comment" spellcheck="true"># 用 last 使登入信息仅留下用户名</span>$ lastroot  pts/1  192.168.201.101 Sat Feb 7 12:35 still logged <span class="token keyword">in</span>root  pts/1  192.168.201.101 Fri Feb 6 12:13 - 18:46 <span class="token punctuation">(</span>06:33<span class="token punctuation">)</span>root  pts/1  192.168.201.254 Thu Feb 5 22:37 - 23:53 <span class="token punctuation">(</span>01:16<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># last 可以输出『账号/终端机/杢源/日期时间』的数据，幵且是排列整齐的</span>$ last <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">' '</span> -f 1<span class="token comment" spellcheck="true">#由输出的结果我们可以发现第一个空格分隔的字段代表账号，所以使用如上指令，但是因为 root pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 pts/1 其实不能用 cut -d ' ' -f 1,2，输出的结果不是我们想要的。</span></code></pre><p>cut 主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字数据的时候！ 这是因为有时候我们会以某些字符当作分割的参数，然后将数据加以切割，以获得我们所需要的数据。</p></li></ul><hr><ul><li><p>grep</p><p>grep 是分析一行信息， 若当中有我们所需要的，就将该行拿出来。</p><p>选项与参数：</p><p>-a ：将 binary 档案以 text 档案的方式搜寻数据</p><p>-c ：计算找到 ‘搜寻字符串’ 的次数</p><p>-i ：忽略大小写的不同，所以大小写视为相同</p><p>-n ：顺便输出行号</p><p>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行</p><p>–color=auto ：可以将找到的关键词部分加上颜色显示</p></li></ul><hr><h3 id="排序命令：sort-wc-uniq"><a href="#排序命令：sort-wc-uniq" class="headerlink" title="排序命令：sort, wc, uniq"></a>排序命令：sort, wc, uniq</h3><ul><li><p>sort</p><p>sort 可以帮我们进行排序，而且可以依据不同的数据型态排序！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 LANG=C 让语系统一，这样数据排序比较好一些。</p><p>选项与参数：</p><p>-f ：忽略大小写的差异</p><p>-b ：忽略最前面的空格符部分</p><p>-M ：以月份的名字排序，例如 JAN, DEC 等等的排序方法</p><p>-n ：使用『纯数字』进行排序(默认是以文字型态排序)</p><p>-r ：反向排序</p><p>-u ：就是 uniq ，相同的数据中，仅出现一行代表</p><p>-t ：分隔符，预设是用 [tab] 键分隔</p><p>-k ：以那个区间 (field) 进行排序的意思</p></li><li><p>uniq</p><p>选项与参数：</p><p>-i ：忽略大小写字符的不同</p><p>-c ：进行计数</p><p>如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位:</span>$ last <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">' '</span> -f1 <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span></code></pre></li><li><p>wc</p><p> wc 这个指令可以帮我们计算输出的信息的整体数据。</p><p>选项与参数：</p><p>-l ：仅列出行</p><p>-w ：仅列出多少字(英文单字)</p><p>-m ：多少字符</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 那个 /etc/man.config 里面到底有多少相关字、行、字符数</span>$ <span class="token function">cat</span> /etc/man.config <span class="token operator">|</span> <span class="token function">wc</span>141 722 4617<span class="token comment" spellcheck="true"># 输出的三个数字中，分别代表： 『行、字数、字符数』</span></code></pre></li></ul><h3 id="字符转换命令：tr-col-join-paste-expand"><a href="#字符转换命令：tr-col-join-paste-expand" class="headerlink" title="字符转换命令：tr, col, join, paste, expand"></a>字符转换命令：tr, col, join, paste, expand</h3><p>DOS 断行字符与 Unix 断行字符不同，并且可以使用 dos2unix  与 unix2dos 完成转换。那么是否还有其他常用的字符替代？ 举个例子，要将大写改成小写，或者是将数据中的 [tab] 按键转成空格键？还有，如何将两篇信息整合成一篇？ 下面是这些字符转换命令在管线当中的使用方法。</p><ul><li><p>tr</p><p>tr 可以用来删除一段信息当中的文字，或者是进行文字信息的替换。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tr</span> <span class="token punctuation">[</span>-ds<span class="token punctuation">]</span> SET1 <span class="token punctuation">..</span>.选项与参数：-d ：删除信息当中的 SET1 这个字符串-s ：取代掉重复的字符<span class="token comment" spellcheck="true"># 将 /etc/passwd 输出的信息中，将冒号 (:) 删除</span>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">':'</span><span class="token comment" spellcheck="true"># 将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span>$ <span class="token function">cp</span> /etc/passwd /root/passwd <span class="token operator">&amp;&amp;</span> unix2dos /root/passwd$ <span class="token function">file</span> /etc/passwd /root/passwd/etc/passwd: ASCII text/root/passwd: ASCII text, with CRLF line terminators <span class="token operator">&lt;=</span><span class="token operator">=</span>就是 DOS 断行$ <span class="token function">cat</span> /root/passwd <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">'\r'</span> <span class="token operator">></span> /root/passwd.linux<span class="token comment" spellcheck="true"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span></code></pre><p>如上面例子当中，可以去除 DOS 档案留下的 ^M 这个断行符号！这东西相当有用，相信处理 Linux &amp;  Windows 系统中人们最麻烦的一件事就是这个事情，亦即是 DOS 底下会自动在每行行尾加入 ^M 这个断行符号。这个时候我们可以使用 tr 将 ^M 去除！ ^M 可以使用 \r 代替！</p></li></ul><hr><ul><li><p>col</p><p>选项与参数：</p><p>-x ：将 tab 键转换成对等的空格键</p><p>-b ：在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空格</span>$ <span class="token function">cat</span> -A /etc/man.config    <span class="token operator">&lt;=</span><span class="token operator">=</span>此时会看到很多 ^I 的符号，那就是 tab$ <span class="token function">cat</span> /etc/man.config <span class="token operator">|</span> col -x <span class="token operator">|</span> <span class="token function">cat</span> -A <span class="token operator">|</span> <span class="token function">more</span>如此一来， <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 键会被替代为空格键，输出就美观多了</code></pre><p>虽然 col 有他特殊的用途，不过很多时候，它可以用来简单地处理将 [tab] 键替换为空格键！ 例如上面的例子，如果使用 cat -A 则 [tab] 会以 ^I 表示。 但经过 col -x 处理，则会将 [tab] 替换成对等的空格键。</p></li></ul><hr><ul><li><p>join</p><p>在处理两个档案之间的数据， 而且，主要是在处理 『两个档案当中，有 “相同数据” 的那一行，才将它加在一起』的意思。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">join</span> <span class="token punctuation">[</span>-ti12<span class="token punctuation">]</span> file1 file2选项与参数：-t ：join 默认以空格符分隔数据，并且比对『第一个字段』的数据，如果两个档案相同，则将两笔数据联成一行，且第一个字段放在第一个-i ：忽略大小写的差异-1 ：这个是数字 1 ，代表『第一个档案要用那个字段来分析』的意思-2 ：代表『第二个档案要用那个字段来分析』的意思。</code></pre><p>需要特别注意的是，在使用 join 之前，你所需要处理的档案应该要事先经过排序 (sort) 处理！ 否则有些比对的项目会被略过。</p></li></ul><hr><ul><li><p>paste</p><p>这个 paste 就要比 join 简单多了！相对于 join 必须要比对两个档案的数据相关性， paste 就直接『将两行贴在一起，且中间以 [tab] 键隔开』。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">paste</span> <span class="token punctuation">[</span>-d<span class="token punctuation">]</span> file1 file2选项与参数：-d ：后面可以接分隔字符。预设是以 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 来分隔的- ：如果 <span class="token function">file</span> 部分写成 - ，表示来自 standard input 的资料的意思。</code></pre></li></ul><hr><ul><li><p>expand</p><p>就是在将 [tab] 转成空格。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">expand</span> <span class="token punctuation">[</span>-t<span class="token punctuation">]</span> <span class="token function">file</span>选项与参数：-t ：后面可以接数字。一般来说，一个 tab 可以用 8 个空格替代。 我们也可以自行定义一个 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 按键代表多少个字符。<span class="token comment" spellcheck="true"># 将 /etc/man.config 内行首为 MANPATH 字样的行取出；仅取前三行</span>$ <span class="token function">grep</span> <span class="token string">'^MANPATH'</span> /etc/man.config <span class="token operator">|</span> <span class="token function">head</span> -n 3MANPATH /usr/manMANPATH /usr/share/manMANPATH /usr/local/man<span class="token comment" spellcheck="true"># 行首的代表标志为 ^ </span><span class="token comment" spellcheck="true"># 承上，如果我想要将所有的符号都列出来呢？(用 cat)</span>$ <span class="token function">grep</span> <span class="token string">'^MANPATH'</span> /etc/man.config <span class="token operator">|</span> <span class="token function">head</span> -n 3 <span class="token operator">|</span><span class="token function">cat</span> -AMANPATH^I/usr/man$MANPATH^I/usr/share/man$MANPATH^I/usr/local/man$<span class="token comment" spellcheck="true"># 发现差别了吗？ [tab] 键可以被 cat -A 显示成为 ^I</span><span class="token comment" spellcheck="true"># 承上，我将 [tab] 设定成 6 个字符</span>$  <span class="token function">grep</span> <span class="token string">'^MANPATH'</span> /etc/man.config <span class="token operator">|</span> <span class="token function">head</span> -n 3 <span class="token operator">|</span> <span class="token function">expand</span> -t 6 - <span class="token operator">|</span> <span class="token function">cat</span> -AMANPATH      /usr/man$MANPATH      /usr/share/man$MANPATH      /usr/local/man$       123456</code></pre><p>unexpand 可以将空格转成 [tab] 。</p></li></ul><h3 id="分割命令：split"><a href="#分割命令：split" class="headerlink" title="分割命令：split"></a>分割命令：split</h3><p> split 可以帮你将一个大档案，依据档案大小或行数来分割，就可以将大档案分割成为小档案了。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">split</span> <span class="token punctuation">[</span>-bl<span class="token punctuation">]</span> <span class="token function">file</span> PREFIX选项与参数：-b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；-l ：以行数来进行分割。PREFIX ：代表前导符的意思，可作为分割档案命名的前导文字。</code></pre><h3 id="参数代换：xargs"><a href="#参数代换：xargs" class="headerlink" title="参数代换：xargs"></a>参数代换：xargs</h3><p>就以字面意义来看， x 是加减乘除的乘号，args 则是 arguments (参数)  的意思，所以说，这个指令就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空格符或断行字符作为分辨，将 stdin 的资料分隔成为 arguments 。 因为是以空格符作为分隔，所 以，如果有一些文件名或者是其他意义的名词内含有空格符的时候， xargs 可能就会误判了。</p><p>使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以透过 xargs 来提供该指令引用 standard input 之用。</p><h3 id="关于减号的用途"><a href="#关于减号的用途" class="headerlink" title="关于减号的用途"></a>关于减号的用途</h3><p>在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 替代。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> -cvf - /home <span class="token operator">|</span> <span class="token function">tar</span> -xvf -<span class="token comment" spellcheck="true"># 上面这个例子是说：『我将 /home 里面的档案打包，但打包的数据不是记录成文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - 』。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 file 了。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Toolkit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VisIt 脚本小记</title>
      <link href="2021/04/15/visit-bi-ji/"/>
      <url>2021/04/15/visit-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Command-Line-Interface-CLI"><a href="#Command-Line-Interface-CLI" class="headerlink" title="Command Line Interface (CLI)"></a>Command Line Interface (<em>CLI</em>)</h2><p>VisIt 所拥有的 <em>CLI</em> 建立在 Python 2.7 的基础上。</p><p>使用 <em>CLI</em> 有如下途径：</p><ol><li><p>在 shell 中启动 VisIt 并运行脚本。</p><pre class=" language-bash"><code class="language-bash">/path/to/visit/bin/visit -nowin -cli -s <span class="token operator">&lt;</span>script.py<span class="token operator">></span></code></pre></li><li><p>启动 VisIt，以便显示可视化窗口，并以交互方式发布命令。</p></li><li><p>同时使用标准 <em>GUI</em> 和 <em>CLI</em>。</p></li></ol><h2 id="打开-CLI"><a href="#打开-CLI" class="headerlink" title="打开 CLI"></a>打开 <em>CLI</em></h2><p>从 <em>GUI</em> 打开 <em>CLI</em>：<em>Controls –&gt; Command</em>.</p><p>这样就可以打开命令窗口。命令窗口提供了一个文本编辑器，其中 Python 语法高亮显示，并提供了一个 Execute 按钮，告诉 VisIt 执行脚本。最后，命令窗口可以将 <em>GUI</em> 操作记录为可以在脚本中使用的 Python 代码。</p><h2 id="简单尝试-CLI"><a href="#简单尝试-CLI" class="headerlink" title="简单尝试 CLI"></a>简单尝试 <em>CLI</em></h2><p>下面是一个简单的例子，绘制数据 <em>temp</em> 的伪色图。</p><p>首先在 <em>GUI</em> 中打开数据文件，然后将下面的代码粘贴到命令窗口。</p><pre class=" language-python"><code class="language-python">AddPlot<span class="token punctuation">(</span><span class="token string">"Pseudocolor"</span><span class="token punctuation">,</span> <span class="token string">"temp"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># You will see the active plots list in the GUI update, since the CLI and GUI communicate.</span>DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># You should see your plot.</span></code></pre><p>然后 Execute。</p><h2 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h2><p>以下皆是 Python 脚本，可以通过以上介绍的方式在 VisIt 中运行。</p><h3 id="设定属性"><a href="#设定属性" class="headerlink" title="设定属性"></a>设定属性</h3><p>VisIt 的绘制和操作都有一系列的属性设置，可以通过 Python 中的对象来控制。</p><p>下面是一个设置伪色图最小值和最大值的例子：</p><pre class=" language-python"><code class="language-python">DeleteAllPlots<span class="token punctuation">(</span><span class="token punctuation">)</span>AddPlot<span class="token punctuation">(</span><span class="token string">"Pseudocolor"</span><span class="token punctuation">,</span> <span class="token string">"temp"</span><span class="token punctuation">)</span>DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span>p <span class="token operator">=</span> PseudocolorAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>minFlag <span class="token operator">=</span> <span class="token number">1</span>p<span class="token punctuation">.</span>maxFlag <span class="token operator">=</span> <span class="token number">1</span>p<span class="token punctuation">.</span>min <span class="token operator">=</span> <span class="token number">3.5</span>p<span class="token punctuation">.</span>max <span class="token operator">=</span> <span class="token number">7.5</span>SetPlotOptions<span class="token punctuation">(</span>p<span class="token punctuation">)</span></code></pre><h3 id="制作等值面动画"><a href="#制作等值面动画" class="headerlink" title="制作等值面动画"></a>制作等值面动画</h3><pre class=" language-python"><code class="language-python">DeleteAllPlots<span class="token punctuation">(</span><span class="token punctuation">)</span>AddPlot<span class="token punctuation">(</span><span class="token string">"Pseudocolor"</span><span class="token punctuation">,</span> <span class="token string">"temp"</span><span class="token punctuation">)</span>iso_atts <span class="token operator">=</span> IsosurfaceAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>iso_atts<span class="token punctuation">.</span>contourMethod <span class="token operator">=</span> iso_atts<span class="token punctuation">.</span>Valueiso_atts<span class="token punctuation">.</span>variable <span class="token operator">=</span> <span class="token string">"temp"</span>AddOperator<span class="token punctuation">(</span><span class="token string">"Isosurface"</span><span class="token punctuation">)</span>DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   iso_atts<span class="token punctuation">.</span>contourValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.1</span><span class="token operator">*</span>i<span class="token punctuation">)</span>   SetOperatorOptions<span class="token punctuation">(</span>iso_atts<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># For moviemaking, you'll need to save off the image</span>   <span class="token comment" spellcheck="true"># SaveWindow()</span></code></pre><h3 id="一个综合应用"><a href="#一个综合应用" class="headerlink" title="一个综合应用"></a>一个综合应用</h3><p>下面使用伪彩色图，并应用 ThreeSlice 运算符在网格外部显示 <em>temp</em> 以及温度梯度的流线。</p><p><img src="https://i.loli.net/2021/04/15/qTXN8mIgP2FoB5O.png" alt="*Streamlines*"></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Clear any previous plots</span>DeleteAllPlots<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Create a plot of the scalar field 'temp'</span>AddPlot<span class="token punctuation">(</span><span class="token string">"Pseudocolor"</span><span class="token punctuation">,</span><span class="token string">"temp"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Slice the volume to show only three</span><span class="token comment" spellcheck="true"># external faces.</span>AddOperator<span class="token punctuation">(</span><span class="token string">"ThreeSlice"</span><span class="token punctuation">)</span>tatts <span class="token operator">=</span> ThreeSliceAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>tatts<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span>tatts<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span>tatts<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span>SetOperatorOptions<span class="token punctuation">(</span>tatts<span class="token punctuation">)</span>DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Find the maximum value of the field 'temp'</span>Query<span class="token punctuation">(</span><span class="token string">"Max"</span><span class="token punctuation">)</span>val <span class="token operator">=</span> GetQueryOutputValue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">"Max value of 'temp' = "</span><span class="token punctuation">,</span> val<span class="token comment" spellcheck="true"># Create a streamline plot that follows</span><span class="token comment" spellcheck="true"># the gradient of 'temp'</span>DefineVectorExpression<span class="token punctuation">(</span><span class="token string">"g"</span><span class="token punctuation">,</span><span class="token string">"gradient(temp)"</span><span class="token punctuation">)</span>AddPlot<span class="token punctuation">(</span><span class="token string">"Pseudocolor"</span><span class="token punctuation">,</span> <span class="token string">"operators/IntegralCurve/g"</span><span class="token punctuation">)</span>iatts <span class="token operator">=</span> IntegralCurveAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>iatts<span class="token punctuation">.</span>sourceType <span class="token operator">=</span> iatts<span class="token punctuation">.</span>SpecifiedBoxiatts<span class="token punctuation">.</span>sampleDensity0 <span class="token operator">=</span> <span class="token number">7</span>iatts<span class="token punctuation">.</span>sampleDensity1 <span class="token operator">=</span> <span class="token number">7</span>iatts<span class="token punctuation">.</span>sampleDensity2 <span class="token operator">=</span> <span class="token number">7</span>iatts<span class="token punctuation">.</span>dataValue <span class="token operator">=</span> iatts<span class="token punctuation">.</span>SeedPointIDiatts<span class="token punctuation">.</span>integrationType <span class="token operator">=</span> iatts<span class="token punctuation">.</span>DormandPrinceiatts<span class="token punctuation">.</span>issueStiffnessWarnings <span class="token operator">=</span> <span class="token number">0</span>iatts<span class="token punctuation">.</span>issueCriticalPointsWarnings <span class="token operator">=</span> <span class="token number">0</span>SetOperatorOptions<span class="token punctuation">(</span>iatts<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># set style of streamlines</span>patts <span class="token operator">=</span> PseudocolorAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>patts<span class="token punctuation">.</span>lineType <span class="token operator">=</span> patts<span class="token punctuation">.</span>Tubepatts<span class="token punctuation">.</span>tailStyle <span class="token operator">=</span> patts<span class="token punctuation">.</span>Spherespatts<span class="token punctuation">.</span>headStyle <span class="token operator">=</span> patts<span class="token punctuation">.</span>Conespatts<span class="token punctuation">.</span>endPointRadiusBBox <span class="token operator">=</span> <span class="token number">0.01</span>SetPlotOptions<span class="token punctuation">(</span>patts<span class="token punctuation">)</span>DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="创建流线动画"><a href="#创建流线动画" class="headerlink" title="创建流线动画"></a>创建流线动画</h3><p>需要安装 ffmpeg 且在工作环境下可用。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># import visit_utils, we will use it to help encode our movie</span><span class="token keyword">from</span> visit_utils <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment" spellcheck="true"># Set a better view</span>ResetView<span class="token punctuation">(</span><span class="token punctuation">)</span>v <span class="token operator">=</span> GetView3D<span class="token punctuation">(</span><span class="token punctuation">)</span>v<span class="token punctuation">.</span>RotateAxis<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">)</span>v<span class="token punctuation">.</span>RotateAxis<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">)</span>SetView3D<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Disable annotations</span>aatts <span class="token operator">=</span> AnnotationAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>aatts<span class="token punctuation">.</span>axes3D<span class="token punctuation">.</span>visible <span class="token operator">=</span> <span class="token number">0</span>aatts<span class="token punctuation">.</span>axes3D<span class="token punctuation">.</span>triadFlag <span class="token operator">=</span> <span class="token number">0</span>aatts<span class="token punctuation">.</span>axes3D<span class="token punctuation">.</span>bboxFlag <span class="token operator">=</span> <span class="token number">0</span>aatts<span class="token punctuation">.</span>userInfoFlag <span class="token operator">=</span> <span class="token number">0</span>aatts<span class="token punctuation">.</span>databaseInfoFlag <span class="token operator">=</span> <span class="token number">0</span>aatts<span class="token punctuation">.</span>legendInfoFlag <span class="token operator">=</span> <span class="token number">0</span>SetAnnotationAttributes<span class="token punctuation">(</span>aatts<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Set basic save options</span>swatts <span class="token operator">=</span> SaveWindowAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The 'family' option controls if visit automatically adds a frame number to</span><span class="token comment" spellcheck="true"># the rendered files. For this example we will explicitly manage the output name.</span><span class="token comment" spellcheck="true">#</span>swatts<span class="token punctuation">.</span>family <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># select PNG as the output file format</span><span class="token comment" spellcheck="true">#</span>swatts<span class="token punctuation">.</span>format <span class="token operator">=</span> swatts<span class="token punctuation">.</span>PNG<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># set the width of the output image</span><span class="token comment" spellcheck="true">#</span>swatts<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">1024</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># set the height of the output image</span><span class="token comment" spellcheck="true">#</span>swatts<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">1024</span><span class="token comment" spellcheck="true">####</span><span class="token comment" spellcheck="true"># Crop streamlines to render them at increasing time values over 50 steps</span><span class="token comment" spellcheck="true">####</span>iatts<span class="token punctuation">.</span>cropValue <span class="token operator">=</span> iatts<span class="token punctuation">.</span>Timeiatts<span class="token punctuation">.</span>cropEndFlag <span class="token operator">=</span> <span class="token number">1</span>iatts<span class="token punctuation">.</span>cropBeginFlag <span class="token operator">=</span> <span class="token number">1</span>iatts<span class="token punctuation">.</span>cropBegin <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> ts <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># set the integral curve attributes to change the where we crop the streamlines</span>    iatts<span class="token punctuation">.</span>cropEnd <span class="token operator">=</span> <span class="token punctuation">(</span>ts <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token number">5</span>    <span class="token comment" spellcheck="true"># update streamline attributes and draw the plot</span>    SetOperatorOptions<span class="token punctuation">(</span>iatts<span class="token punctuation">)</span>    DrawPlots<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#before we render the result, explicitly set the filename for this render</span>    swatts<span class="token punctuation">.</span>fileName <span class="token operator">=</span> <span class="token string">"streamline_crop_example_%04d.png"</span> <span class="token operator">%</span> ts    SetSaveWindowAttributes<span class="token punctuation">(</span>swatts<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># render the image to a PNG file</span>    SaveWindow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">################</span><span class="token comment" spellcheck="true"># use visit_utils.encoding to encode these images into a "wmv" movie</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The encoder looks for a printf style pattern in the input path to identify the frames of the movie.</span><span class="token comment" spellcheck="true"># The frame numbers need to start at 0.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The encoder selects a set of decent encoding settings based on the extension of the</span><span class="token comment" spellcheck="true"># the output movie file (second argument). In this case we will create a "wmv" file.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Other supported options include ".mpg", ".mov".</span><span class="token comment" spellcheck="true">#   "wmv" is usually the best choice and plays on all most all platforms (Linux ,OSX, Windows).</span><span class="token comment" spellcheck="true">#   "mpg" is lower quality, but should play on any platform.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># 'fdup' controls the number of times each frame is duplicated.</span><span class="token comment" spellcheck="true">#  Duplicating the frames allows you to slow the pace of the movie to something reasonable.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">################</span>input_pattern <span class="token operator">=</span> <span class="token string">"streamline_crop_example_%04d.png"</span>output_movie <span class="token operator">=</span> <span class="token string">"streamline_crop_example.wmv"</span>encoding<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>input_pattern<span class="token punctuation">,</span>output_movie<span class="token punctuation">,</span>fdup<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><h2 id="学习-CLI"><a href="#学习-CLI" class="headerlink" title="学习 CLI"></a>学习 <em>CLI</em></h2><ol><li><p>可以通过以下命令得到可用命令表</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"dir()"</span> <span class="token operator">|</span> visit -cli -nowin -forceinteractivecli <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">','</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" '"</span> <span class="token operator">|</span> <span class="token function">sort</span></code></pre><p>如果想寻找与特定功能有关的 <em>CLI</em> 功能</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"dir()"</span> <span class="token operator">|</span> visit -cli -nowin -forceinteractivecli <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">','</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" '"</span> <span class="token operator">|</span> <span class="token function">grep</span> -i material</code></pre></li><li><p>通过键入 <em>help(MethodName)</em> 来学习特定方法的语法</p></li><li><p>可以把 <em>GUI</em> 中的操作转录为 Python 脚本</p></li><li><p><em>WriteScript()</em> 函数可以把当前的绘制转录为 Python 脚本</p></li><li><p>对一个 Python 对象，可通过 <em>print</em> 来看它的属性</p><pre class=" language-python"><code class="language-python">s <span class="token operator">=</span> SliceAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> s<span class="token comment" spellcheck="true"># Output:</span>originType <span class="token operator">=</span> Intercept  <span class="token comment" spellcheck="true"># Point, Intercept, Percent, Zone, Node</span>originPoint <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>originIntercept <span class="token operator">=</span> <span class="token number">0</span>originPercent <span class="token operator">=</span> <span class="token number">0</span>originZone <span class="token operator">=</span> <span class="token number">0</span>originNode <span class="token operator">=</span> <span class="token number">0</span>normal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>axisType <span class="token operator">=</span> YAxis  <span class="token comment" spellcheck="true"># XAxis, YAxis, ZAxis, Arbitrary, ThetaPhi</span>upAxis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>project2d <span class="token operator">=</span> <span class="token number">1</span>interactive <span class="token operator">=</span> <span class="token number">1</span>flip <span class="token operator">=</span> <span class="token number">0</span>originZoneDomain <span class="token operator">=</span> <span class="token number">0</span>originNodeDomain <span class="token operator">=</span> <span class="token number">0</span>meshName <span class="token operator">=</span> <span class="token string">"default"</span>theta <span class="token operator">=</span> <span class="token number">0</span>phi <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>更多内容可以参看<a href="https://visit-sphinx-github-user-manual.readthedocs.io/en/develop/index.html">官方手册</a>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Toolkit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署博客404——大小写问题</title>
      <link href="2021/03/30/hexo-da-xiao-xie-wen-ti/"/>
      <url>2021/03/30/hexo-da-xiao-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="404？令人抓狂的问题"><a href="#404？令人抓狂的问题" class="headerlink" title="404？令人抓狂的问题"></a>404？令人抓狂的问题</h2><p>第一次部署，一切都很顺利，还兴奋了一会儿，但是更新了几次之后，一篇博客404了······</p><p>本地运行 hexo server，一点问题都没有，正常打开，但是部署上去就404。</p><p>网上各种查找，一般都说是 GitHub 库名称的问题。自己检查了一下，没发现问题，不然第一次也不会成功T^T</p><p>找不到问题所在，有点抓狂······</p><h2 id="终于找到问题"><a href="#终于找到问题" class="headerlink" title="终于找到问题"></a>终于找到问题</h2><p>虽说没查到正确的问题，但是基本明确了一点，应该是链接指向的问题，遂进入 GitHub 库查看文件。</p><p>这一看，还真发现了问题，我的博客名有的大写有的小写，而链接的地址一律都是小写的······</p><p>尝试把链接地址对应的字母大写，正确打开了。哈！问题原来在这！</p><p>接着查问题就很快了，原因应该是 git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。可能是我什么时候强迫症犯了，改过了文件名大小写，导致的404。</p><h2 id="对症下药"><a href="#对症下药" class="headerlink" title="对症下药"></a>对症下药</h2><h3 id="首先需要搞定大小写敏感的问题"><a href="#首先需要搞定大小写敏感的问题" class="headerlink" title="首先需要搞定大小写敏感的问题"></a>首先需要搞定大小写敏感的问题</h3><p>进入博客项目的 <em>.deploy_git</em> 文件夹，修改 <em>.git</em> 下的 <em>config</em> 文件，将</p><pre class=" language-bash"><code class="language-bash">ignorecase<span class="token operator">=</span>true</code></pre><p>改为</p><pre class=" language-bash"><code class="language-bash">ignorecase<span class="token operator">=</span>false</code></pre><h3 id="接下来更新博客"><a href="#接下来更新博客" class="headerlink" title="接下来更新博客"></a>接下来更新博客</h3><p>删除博客项目中 <em>.deploy_git</em> 文件夹下所有文件，并 push 到 GitHub 上：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> .deploy_git$ <span class="token function">git</span> <span class="token function">rm</span> -rf *$ <span class="token function">git</span> commit -m <span class="token string">'clean all file'</span>$ <span class="token function">git</span> push</code></pre><p>使用 hexo 再次生成文件并部署：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token punctuation">..</span>$ hexo clean$ hexo generate$ hexo deploy</code></pre><p>问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P&amp;S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hi There</title>
      <link href="2021/03/27/hi-there/"/>
      <url>2021/03/27/hi-there/</url>
      
        <content type="html"><![CDATA[<h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h2><p>It’s my first blog and a little test at the same time.</p><p>It’s raining outside but I’m pretty excited.</p><p>I hope interesting things can be record here.</p><h2 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy~"></a>Enjoy~</h2>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/27/hello-world/"/>
      <url>2021/03/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
